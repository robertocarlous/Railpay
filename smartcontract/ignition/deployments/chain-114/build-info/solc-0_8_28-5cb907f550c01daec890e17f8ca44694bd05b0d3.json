{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-5cb907f550c01daec890e17f8ca44694bd05b0d3",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/BatchPayout.sol": "project/contracts/BatchPayout.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/BatchPayout.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\nimport \"./IERC20.sol\";\n\n/**\n * @title BatchPayout\n * @notice Contract for batch payouts using USDT0 on Flare Network\n * @dev Integrates with ProofRails for payment verification\n */\ncontract BatchPayout {\n    IERC20 public immutable usdt0;\n    address public owner;\n    \n    // Payout tracking\n    struct Payout {\n        uint256 payoutId;\n        address initiator;\n        uint256 totalAmount;\n        uint256 recipientCount;\n        uint256 timestamp;\n        bool completed;\n        string proofRailsId; // ProofRails verification ID\n    }\n    \n    // Recipient payment tracking\n    struct RecipientPayment {\n        address recipient;\n        uint256 amount;\n        uint256 payoutId;\n        bool paid;\n        uint256 timestamp;\n    }\n    \n    // Mapping from payout ID to payout details\n    mapping(uint256 => Payout) public payouts;\n    \n    // Mapping from payout ID to recipient payments\n    mapping(uint256 => RecipientPayment[]) public payoutRecipients;\n    \n    // Mapping from recipient address to their payment history\n    mapping(address => RecipientPayment[]) public recipientHistory;\n    \n    // Counter for payout IDs\n    uint256 private payoutCounter;\n    \n    // Events for ProofRails integration\n    // These events contain all data needed for ProofRails API call\n    // Note: Arrays cannot be emitted directly, so we emit individual PaymentExecuted events\n    event PayoutCreated(\n        uint256 indexed payoutId,\n        address indexed initiator,\n        uint256 totalAmount,\n        uint256 recipientCount,\n        uint256 timestamp,\n        string payoutRef\n    );\n    \n    event PaymentExecuted(\n        uint256 indexed payoutId,\n        address indexed recipient,\n        uint256 amount,\n        uint256 timestamp,\n        string payoutRef\n    );\n    \n    event PayoutCompleted(\n        uint256 indexed payoutId,\n        address indexed initiator,\n        uint256 totalAmount,\n        uint256 recipientCount,\n        uint256 timestamp,\n        string payoutRef\n    );\n    \n    event ProofRailsIdUpdated(\n        uint256 indexed payoutId,\n        string oldProofRailsId,\n        string newProofRailsId\n    );\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"BatchPayout: caller is not the owner\");\n        _;\n    }\n    \n    /**\n     * @dev Constructor\n     * @param _usdt0Address Address of the USDT0 token contract on Flare\n     */\n    constructor(address _usdt0Address) {\n        require(_usdt0Address != address(0), \"BatchPayout: invalid USDT0 address\");\n        usdt0 = IERC20(_usdt0Address);\n        owner = msg.sender;\n        payoutCounter = 1;\n    }\n    \n    /**\n     * @dev Execute batch payout to multiple recipients\n     * @param recipients Array of recipient addresses\n     * @param amounts Array of amounts to pay (in USDT0 decimals)\n     * @param payoutRef Optional reference string for ProofRails (e.g., \"payout:123\")\n     * @return payoutId The ID of the created payout\n     * @notice This function emits events that should be listened to by the frontend\n     *         The frontend will then call ProofRails API with the transaction hash\n     *         and update the proofRailsId using updateProofRailsId()\n     */\n    function batchPayout(\n        address[] calldata recipients,\n        uint256[] calldata amounts,\n        string calldata payoutRef\n    ) external returns (uint256) {\n        require(recipients.length > 0, \"BatchPayout: no recipients\");\n        require(recipients.length == amounts.length, \"BatchPayout: array length mismatch\");\n        \n        uint256 payoutId = payoutCounter++;\n        uint256 totalAmount = 0;\n        \n        // Calculate total amount and validate\n        for (uint256 i = 0; i < recipients.length; i++) {\n            require(recipients[i] != address(0), \"BatchPayout: invalid recipient address\");\n            require(amounts[i] > 0, \"BatchPayout: amount must be greater than 0\");\n            totalAmount += amounts[i];\n        }\n        \n        // Check allowance and balance\n        require(\n            usdt0.allowance(msg.sender, address(this)) >= totalAmount,\n            \"BatchPayout: insufficient allowance\"\n        );\n        require(\n            usdt0.balanceOf(msg.sender) >= totalAmount,\n            \"BatchPayout: insufficient balance\"\n        );\n        \n        // Create payout record (proofRailsId will be updated after ProofRails API call)\n        payouts[payoutId] = Payout({\n            payoutId: payoutId,\n            initiator: msg.sender,\n            totalAmount: totalAmount,\n            recipientCount: recipients.length,\n            timestamp: block.timestamp,\n            completed: false,\n            proofRailsId: \"\" // Will be set after ProofRails API call\n        });\n        \n        // Execute transfers and record payments\n        for (uint256 i = 0; i < recipients.length; i++) {\n            // Transfer USDT0 from sender to recipient\n            require(\n                usdt0.transferFrom(msg.sender, recipients[i], amounts[i]),\n                \"BatchPayout: transfer failed\"\n            );\n            \n            // Record recipient payment\n            RecipientPayment memory payment = RecipientPayment({\n                recipient: recipients[i],\n                amount: amounts[i],\n                payoutId: payoutId,\n                paid: true,\n                timestamp: block.timestamp\n            });\n            \n            payoutRecipients[payoutId].push(payment);\n            recipientHistory[recipients[i]].push(payment);\n            \n            // Emit event for ProofRails with payoutRef\n            // Frontend will use this to call ProofRails API for each recipient\n            string memory paymentRef = string(abi.encodePacked(\n                payoutRef,\n                \":recipient:\",\n                _uint2str(i)\n            ));\n            emit PaymentExecuted(payoutId, recipients[i], amounts[i], block.timestamp, paymentRef);\n        }\n        \n        // Mark payout as completed\n        payouts[payoutId].completed = true;\n        \n        // Emit events with all data needed for ProofRails integration\n        // Frontend will listen to these events and call ProofRails API\n        // The PaymentExecuted events below contain individual recipient data\n        emit PayoutCreated(\n            payoutId,\n            msg.sender,\n            totalAmount,\n            recipients.length,\n            block.timestamp,\n            payoutRef\n        );\n        \n        emit PayoutCompleted(\n            payoutId,\n            msg.sender,\n            totalAmount,\n            recipients.length,\n            block.timestamp,\n            payoutRef\n        );\n        \n        return payoutId;\n    }\n    \n    /**\n     * @dev Update ProofRails ID for a payout\n     * @param payoutId The payout ID to update\n     * @param newProofRailsId The ProofRails receipt ID returned from API\n     * @notice This should be called by the frontend/backend after successfully\n     *         calling ProofRails API with the transaction hash\n     */\n    function updateProofRailsId(\n        uint256 payoutId,\n        string calldata newProofRailsId\n    ) external {\n        require(payouts[payoutId].payoutId != 0, \"BatchPayout: payout does not exist\");\n        require(bytes(newProofRailsId).length > 0, \"BatchPayout: invalid proofRailsId\");\n        // Allow anyone to update (frontend/backend will call this after ProofRails API)\n        // In production, you might want to add access control\n        \n        string memory oldProofRailsId = payouts[payoutId].proofRailsId;\n        payouts[payoutId].proofRailsId = newProofRailsId;\n        \n        emit ProofRailsIdUpdated(payoutId, oldProofRailsId, newProofRailsId);\n    }\n    \n    /**\n     * @dev Get payout details\n     * @param payoutId The payout ID\n     * @return payout The payout details\n     */\n    function getPayout(uint256 payoutId) external view returns (Payout memory) {\n        return payouts[payoutId];\n    }\n    \n    /**\n     * @dev Get all recipients for a payout\n     * @param payoutId The payout ID\n     * @return recipients Array of recipient payments\n     */\n    function getPayoutRecipients(uint256 payoutId) external view returns (RecipientPayment[] memory) {\n        return payoutRecipients[payoutId];\n    }\n    \n    /**\n     * @dev Get payment history for a recipient\n     * @param recipient The recipient address\n     * @return payments Array of recipient payments\n     */\n    function getRecipientHistory(address recipient) external view returns (RecipientPayment[] memory) {\n        return recipientHistory[recipient];\n    }\n    \n    /**\n     * @dev Get total number of payouts\n     * @return count Total payout count\n     */\n    function getPayoutCount() external view returns (uint256) {\n        return payoutCounter - 1;\n    }\n    \n    /**\n     * @dev Transfer ownership of the contract\n     * @param newOwner The new owner address\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"BatchPayout: invalid new owner\");\n        owner = newOwner;\n    }\n    \n    /**\n     * @dev Internal function to convert uint to string\n     * @param _i The uint to convert\n     * @return _uintAsString The string representation\n     */\n    function _uint2str(uint256 _i) internal pure returns (string memory) {\n        if (_i == 0) {\n            return \"0\";\n        }\n        uint256 j = _i;\n        uint256 len;\n        while (j != 0) {\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint256 k = len;\n        while (_i != 0) {\n            k = k-1;\n            uint8 temp = (48 + uint8(_i - _i / 10 * 10));\n            bytes1 b1 = bytes1(temp);\n            bstr[k] = b1;\n            _i /= 10;\n        }\n        return string(bstr);\n    }\n}\n"
      },
      "project/contracts/IERC20.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address account) external view returns (uint256);\n    function transfer(address to, uint256 amount) external returns (bool);\n    function allowance(address owner, address spender) external view returns (uint256);\n    function approve(address spender, uint256 amount) external returns (bool);\n    function transferFrom(address from, address to, uint256 amount) external returns (bool);\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
      }
    }
  }
}